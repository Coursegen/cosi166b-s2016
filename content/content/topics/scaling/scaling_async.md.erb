---
title: Scaling with Asynchronous processing
---
### Scaling Pattern: Asycnhronous processing
* Real examples: <%= discussion "What do all of these have in common?" %>
  * Account registraton confirmation emails (actually all emails)
  * Daily (periodic or episodic) notification emails
  * Automatic backups or archiving
  * Image Resizing
  * Spam checking

* Synchronous: Caller **waits** for response
* Asynchronous: Request returns immediately, but result comes later

* <%= nb "web server mainly responds to http requests!" %>
* Background processing happens even if no requests!
* How do processes work in a modern Operating System?
  * Scheduler part of the OS
  * Processes can be fairly heavy weight
  * Let's estimate how many background processs you would need
  * How would you handle processes that:
    * Were taking too long?
    * Had crashed?
    * Needed to be restarted?
    * Or what if the server crashes as a whole?
    * It's a mess. Need abstractions!

##### Case 1: Schedule based
* CRON jobs. Most elementary. Require "privileges"
* Alternative: Native "scheduler" application (e.g. Heroku Simple Job Scheduler)
* References:
  * [Heroku Simple Job Scheduler](https://devcenter.heroku.com/articles/scheduled-jobs-custom-clock-processes#simple-job-scheduling)
  * [Unix Cron](http://en.wikipedia.org/wiki/Cron)
  * [Creating Cron Jobs on Mac](http://www.maclife.com/article/columns/terminal_101_creating_cron_jobs)
  * [Rails Runner](http://guides.rubyonrails.org/command_line.html#rails-runner)

##### Case 2: Request based
* Request handled 'asynchronously' of course
* By local server, in a separate process
* By a remote server
* Request queueing
  * What happens when requests come faster than we can handle them
  * How do we add more performance in handling request
* References
  * [Comparing Background processing Libraries](http://www.sitepoint.com/comparing-ruby-background-processing-libraries-delayed-job/)
  * [Rails Delayed Job Gem](https://github.com/collectiveidea/delayed_job)
